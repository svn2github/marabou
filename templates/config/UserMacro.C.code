#include "iostream.h"
#include "iomanip.h"
#include "TEnv.h"
#include "TObject.h"
#include "TMrbConfig.h"
#include "TMrbNamedX.h"
#include "TMrbLofNamedX.h"
#include "TMrbTemplate.h"
#include "TMrbLogger.h"
#include "SetColor.h"

//_______________________________________________________________[PROTO TYPES]
//////////////////////////////////////////////////////////////////////////////
void UserMacro(ofstream * Strm, TMrbConfig * CfgBase, TObject * CfgObject, const Char_t * TagWord, Bool_t * Result);
Bool_t ProcessUserTemplate(ofstream * Strm, const Char_t * TmplFile, TMrbConfig * CfgBase, TObject * CfgObject, Int_t TagIndex);


//________________________________________________________________[ROOT MACRO]
//////////////////////////////////////////////////////////////////////////////
// Name:             UserMacro.C
// Purpose:          User macro to be called when generating code
// Description:      ROOT macro to be called by methods TMrbConfig::Make<XXX>Code().
//                   May be used to insert user-specific code
// Author:           %%AUTHOR%%
// Revision:         
// Date:             %%CREATION_DATE%%
// URL:              
// Keywords:
//////////////////////////////////////////////////////////////////////////////

enum	EUserTags	{	kUserTagXXX 	= 0
					};
					
TMrbLofNamedX UserTags;


void UserMacro(	ofstream * Strm,
				TMrbConfig * CfgBase,
				TObject * CfgObject,
				const Char_t * TagWord,
				Bool_t * Result 			) {
//________________________________________________________________[C FUNCTION]
//////////////////////////////////////////////////////////////////////////////
// Name:             UserMacro
// Purpose:          Generate user-specific code
// Arguments:        ofstream * Strm         -- output stream
//                   TMrbConfig * CfgBase    -- pointer to config base class
//                   TObject * CfgObject     -- pointer to config object in scope,
//                                                 i.e. TMrbEvent, TMrbSubevent,
//                                                      TMrbModule ...
//                   Char_t * TagWord        -- tag word taken from template file
// Results:          Bool_t * Result         -- return flag:
//                                                 kTRUE  -> code generation completed
//                                                           for given tag word
//                                                 kFALSE -> code has to be generated by
//                                                           MARaBOU afterwards
// Exceptions:       
// Description:      This function will be called by methods TMrbConfig::Make<XXX>Code()
//                   to generate code different from that provided by system templates.
//                   User may decide whether
//                       (a) to create his own code REPLACING system code
//                           (set *Result = kTRUE on return)
//                   or  (b) to create code IN ADDITION to system code
//                           (set *Result = kFALSE on return)
//                   In case of errors one should set *Result=kTRUE on return
//                   to terminate code generation for the tag word given.
// Keywords:         
/////////////////////////////////////////////////////////////////////////////

	TMrbNamedX * nx;

	static Bool_t onceOnly = kFALSE;
	TMrbLogger * msgLog = CfgBase->GetMessageLogger();
	
	if (nx = UserTags.FindByName(TagWord)) {
		switch (nx->GetIndex()) {
			case kUserTagXXX:
			default:	break;
		}
	}
	// no code implemented - remove once-only code after having added your own code ...
	if (!onceOnly) {
		msgLog->Err()	<< setred << "No user code present (file has to be edited first!)" << setblack << endl;
		msgLog->Flush("UserMacro.C");
		onceOnly = kTRUE;
	}
	*Result = kFALSE;			// code will be generated via system templates
}

Bool_t ProcessUserTemplate(	ofstream * Strm,
							const Char_t * TmplFile,
							TMrbConfig * CfgBase,
							TObject * CfgObject,
							Int_t TagIndex			 ) {
//________________________________________________________________[C FUNCTION]
//////////////////////////////////////////////////////////////////////////////
// Name:             ProcessUserTemplate
// Purpose:          Generate user-specific code according to template file
// Arguments:        ofstream * Strm         -- output stream
//                   Char_t * TmplFile       -- name of template file to be processed
//                   TMrbConfig * CfgBase    -- pointer to config base class
//                   TObject * CfgObject     -- pointer to config object in scope,
//                                                 i.e. TMrbEvent, TMrbSubevent,
//                                                      TMrbModule ...
//                   Int_t TagIndex          -- tag word index
// Results:          kTRUE/kFALSE
// Exceptions:       
// Description:      Generates code according to template file & tag word index.
//                       (a)  Opens template file
//                       (b1) TagIndex >= 0:  Searches for given TagIndex and processes it.
//                       (b2) TagIndex == -1: Loops thru template file and processes ALL tags
//                       (c1) Returns Result=kTRUE if generated code REPLACES system code
//                       (c2) Returns Result=kFALSE on error or if code is add-on to existing
//                            systemn code
// Keywords:         
/////////////////////////////////////////////////////////////////////////////

	TMrbLogger * msgLog = CfgBase->GetMessageLogger();
	TString tmplPath = gEnv->GetValue("TMrbConfig.TemplatePath", ".:config:$(MARABOU)/templates/config");
	TString tf = TmplFile;
	gSystem->ExpandPathName(tmplPath);

	const Char_t * fp = gSystem->Which(tmplPath.Data(), tf.Data());
	if (fp == NULL) {
		msgLog->Err()	<< "Template file not found -" << endl
						<<           "                 Searching on path " << tmplPath << endl
						<<           "                 for file          " << tf << endl;
		msgLog->Flush("UserMacro.C");
		return(kFALSE);
	} else if (CfgBase->IsVerbose()) {
		msgLog->Out()	<< "Using template file " << fp << endl;
		msgLog->Flush("UserMacro.C");
	}
	
	tf = fp;
	
	TMrbTemplate tmpl;
	TString line;
	if (tmpl.Open(tf.Data(), &UserTags)) {
		if (TagIndex == -1) {
			for (;;) {
				TMrbNamedX * tag = tmpl.Next(line);
				if (tmpl.IsEof()) break;
				if (tmpl.IsError()) continue;
				if (tmpl.Status() & TMrbTemplate::kNoTag) {
					if (line.Index("//-") != 0) *Strm << line << endl;
				} else {
					switch (tag->GetIndex()) {
						default:	return(kFALSE);
					}
				}
			}
		} else {
			for (;;) {
				TMrbNamedX * tag = tmpl.Next(line);
				if (tmpl.IsEof()) break;
				if (tmpl.IsError()) continue;
				if (!(tmpl.Status() & TMrbTemplate::kNoTag)) {
					if (TagIndex == tag->GetIndex()) {
						switch (TagIndex) {
							default:	return(kTRUE);
						}
					}
				}
			}
		}
	}
	return(kTRUE);
}

void UserMacroInit() {
//________________________________________________________________[C FUNCTION]
//////////////////////////////////////////////////////////////////////////////
// Name:             UserMacroInit
// Purpose:          Initialize user macro
// Arguments:        --
// Results:          --
// Exceptions:       
// Description:      This function will be called by class TMrbConfig to initialize
//                   user's code generation. One of its tasks could be to
//                   provide a list of tag words and their indices to be used by
//                   the main function.
//                   It MUST EXIST (even if it is empty).
// Keywords:         
/////////////////////////////////////////////////////////////////////////////

	UserTags.SetName("User Tags");
	UserTags.AddNamedX(kUserTagXXX, "USER_TAG_XXX");									
}

