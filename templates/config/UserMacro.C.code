static const Char_t setblack[]	=	"\033[30m";
static const Char_t setred[]		=	"\033[31m";
static Bool_t onceOnly = kFALSE;

//________________________________________________________________[ROOT MACRO]
//////////////////////////////////////////////////////////////////////////////
// Name:             %%USER_MACRO_NAME_UC%%UserMacro.C
// Purpose:          User macro to be called when generating code
// Description:      ROOT macro to be called by methods TMrbConfig::Make<XXX>Code().
//                   May be used to insert user-specific code
// Author:           %%AUTHOR%%
// Revision:         
// Date:             %%CREATION_DATE%%
// URL:              
// Keywords:
//////////////////////////////////////////////////////////////////////////////

enum	EUserTags	{	kUserTagXXX 	= 0
					};
					
TMrbLofNamedX userTags;

void %%USER_MACRO_NAME%%UserMacro(ofstream * Strm, Bool_t * Result, TMrbConfig * CfgBase, TObject * CfgObject, const Char_t * TagWord, Bool_t * Result) {
//________________________________________________________________[C FUNCTION]
//////////////////////////////////////////////////////////////////////////////
// Name:             %%USER_MACRO_NAME%%UserMacro
// Purpose:          Generate user-specific code
// Arguments:        ofstream * Strm         -- output stream
//                   TMrbConfig * CfgBase    -- pointer to config base class
//                   TObject * CfgObject     -- pointer to config object in scope,
//                                                 i.e. TMrbEvent, TMrbSubevent,
//                                                      TMrbModule ...
//                   Char_t * TagWord        -- tag word taken from template file
// Results:          Bool_t * Result         -- return flag:
//                                                 kTRUE  -> code generation completed
//                                                           for given tag word
//                                                 kFALSE -> code has to be generated by
//                                                           MARaBOU afterwards
// Exceptions:       
// Description:      This function will be called by methods TMrbConfig::Make<XXX>Code()
//                   to generate code different from that provided by system templates.
//                   User may decide whether
//                       (a) to create his own code REPLACING system code
//                           (set *Result = kTRUE on return)
//                   or  (b) to create code IN ADDITION to system code
//                           (set *Result = kFALSE on return)
//                   In case of errors one should set *Result=kTRUE on return
//                   to terminate code generation for the tag word given.
// Keywords:         
/////////////////////////////////////////////////////////////////////////////

	TMrbNamedX * nx;

	TMrbLogger * msgLog = CfgBase->GetMessageLogger();
	
	if (nx = userTags.FindByName(TagWord)) {
		switch (nx->GetIndex()) {
			case kUserTagXXX:
			default:	break;
		}
	}
	// no code implemented - remove once-only code after having added your own code ...
	if (!onceOnly) {
		msgLog->Err()	<< setred << "No user code present (file has to be edited first!)" << setblack << endl;
		msgLog->Flush("%%USER_MACRO_FILE%%");
		onceOnly = kTRUE;
	}
	*Result = kFALSE;			// code will be generated via system templates
}

void %%USER_MACRO_NAME%%ProcessUserTemplate(ofstream * Strm, const Char_t * TmplFile,
						TMrbConfig * CfgBase, TObject * CfgObject, Int_t TagIndex) {
//________________________________________________________________[C FUNCTION]
//////////////////////////////////////////////////////////////////////////////
// Name:             %%USER_MACRO_NAME%%ProcessUserTemplate
// Purpose:          Generate user-specific code according to template file
// Arguments:        ofstream * Strm         -- output stream
//                   Char_t * TmplFile       -- name of template file to be processed
//                   TMrbConfig * CfgBase    -- pointer to config base class
//                   TObject * CfgObject     -- pointer to config object in scope,
//                                                 i.e. TMrbEvent, TMrbSubevent,
//                                                      TMrbModule ...
//                   Int_t TagIndex          -- tag word index
// Results:          --
// Exceptions:       
// Description:      Generates code according to template file & tag word index.
//                       (a)  Opens template file
//                       (b1) TagIndex >= 0:  Searches for given TagIndex and processes it.
//                       (b2) TagIndex == -1: Loops thru template file and processes ALL tags
// Keywords:         
/////////////////////////////////////////////////////////////////////////////

	TMrbTemplate tmpl;
	TMrbNamedX * tag;
	Int_t tagIdx;
	TString line;

	TString tf;
	TString tmplPath;
	const Char_t * fp;
	TString macroName;
	
	TMrbLogger * msgLog = CfgBase->GetMessageLogger();
	
	tmplPath = gEnv->GetValue("TMrbConfig.TemplatePath", ".:config:$(MARABOU)/templates/config");
	tf = TmplFile;
	gSystem->ExpandPathName(tmplPath);
	fp = gSystem->Which(tmplPath.Data(), tf.Data());
	if (fp == NULL) {
		msgLog->Err()	<< setred << "Template file not found -" << endl
						<< "                  Searching on path " << tmplPath << endl
						<< "                  for file          " << tf << setblack << endl;
		msgLog->Flush("%%USER_MACRO_FILE%%");
		return;
	} else if (CfgBase->IsVerbose()) {
		msgLog->Out()	<< "Using template file " << fp << endl;
		msgLog->Flush("%%USER_MACRO_FILE%%");
	}
	
	tf = fp;
	
	if (tmpl.Open(tf.Data(), &DgfTags)) {
		if (TagIndex == -1) {
			for (;;) {
				tag = tmpl.Next(line);
				if (tmpl.IsEof()) break;
				if (tmpl.IsError()) continue;
				if (tmpl.Status() & TMrbTemplate::kNoTag) {
					if (line.Index("//-") != 0) *Strm << line << endl;
				} else {
					switch (tagIdx = tag->GetIndex()) {
						default:	break;
					}
				}
			}
		} else {
			for (;;) {
				tag = tmpl.Next(line);
				if (tmpl.IsEof()) break;
				if (tmpl.IsError()) continue;
				if ((!tmpl.Status() & TMrbTemplate::kNoTag)) {
					if (TagIndex == tag->GetIndex()) {
					}
				}
			}
		}
	}
}

void %%USER_MACRO_NAME%%UserMacroInit() {
//________________________________________________________________[C FUNCTION]
//////////////////////////////////////////////////////////////////////////////
// Name:             %%USER_MACRO_NAME%%UserMacroInit
// Purpose:          Initialize user macro
// Arguments:        --
// Results:          --
// Exceptions:       
// Description:      This function will be called by class TMrbConfig to initialize
//                   user's code generation. One of its tasks could be to
//                   provide a list of tag words and their indices to be used by
//                   the main function.
//                   It MUST EXIST (even if it is empty).
// Keywords:         
/////////////////////////////////////////////////////////////////////////////

	userTags.SetName("User Tags");
	userTags.AddNamedX(kUserTagXXX, "USER_TAG_XXX");										
}
