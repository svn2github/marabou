
//______________________________________________________[C++ CLASS DEFINITION]
//////////////////////////////////////////////////////////////////////////////
// Name:           TUsrSevt%%SEVT_NAME_UC%%
// Purpose:        Define a user-specific subevent class
// Description:    %%SEVT_TITLE%%
// Keywords:       
//////////////////////////////////////////////////////////////////////////////

class TUsrSevt%%SEVT_NAME_UC%% : public TObject {

// declare all parent events as friends
// so user may address subevent data directly from event level
%%BeginOfCode%%
	friend class TUsrEvt$className;
%%EndOfCode%%
%%SEVT_FRIENDS%%

	public:

		enum	{	kNofChannels	=	8	};
		enum	{	kNofGroups		=	4	};

	public:
		TUsrSevt%%SEVT_NAME_UC%%() {			// default ctor
			fSevtName = "%%SEVT_NAME_LC%%";
		};
		~TUsrSevt%%SEVT_NAME_UC%%() {};			// default dtor

		inline const Char_t * GetName() const { return(fSevtName.Data()); };
		inline Int_t GetSerial() const { return(kMrbSevt%%SEVT_NAME_UC%%); };

		Bool_t FillSubevent(const UShort_t * SevtData, Int_t SevtWC, Int_t TimeStamp);	// fill subevent from MBS data
		Bool_t BookParams();					// book params
 		void Reset(Int_t InitValue = 0, Bool_t DataOnly = kFALSE);		// reset param data
 		Bool_t BookHistograms();				// book histograms
 		Bool_t FillHistograms();				// fill histograms
		Bool_t AddBranch(TTree * Tree);				// add a branch to the tree
		Bool_t InitializeBranch(TTree * Tree);		// init branch addresses (replay mode only)
		inline Int_t GetTimeStamp() const { return(fTimeStamp); };	// return time stamp (100 microsecs since start)

		inline void SetTriggered(Int_t Channel, Bool_t Flag = kTRUE) { fChanTriggered[Channel] = Flag; };
		inline Bool_t IsTriggered(Int_t Channel) { return(fChanTriggered[Channel]); };
		inline void SetOverflow(Int_t Channel, Bool_t Flag = kTRUE) { fChanOverflow[Channel] = Flag; };
		inline Bool_t HasOverflow(Int_t Channel) { return(fChanOverflow[Channel]); };
		inline void SetSize(Int_t Channel, Int_t Size) { fDataSize[Channel] = Size; };
		inline Bool_t GetSize(Int_t Channel) { return(fDataSize[Channel]); };
		inline void SetPageSize(Int_t Channel, Int_t PageSize) { fPageSize[Channel] = PageSize; };
		inline Int_t GetPageSize(Int_t Channel) { return(fPageSize[Channel]); };

//%%SEVT_USER_METHODS%%			user-specific methods may be included here

												// get param addr (method needed to access params from outside, eg. in macros)
%%BeginOfCode%%
		inline UInt_t * GetAddr$paramNameUC$type() { return($paramNameLC$type); };	// addr of $paramNameLC$type
%%EndOfCode%%
%%SEVT_DEFINE_ADDR%%

		inline Int_t GetIndex() const { return(kMrbSevt%%SEVT_NAME_UC%%); };			// subevent index
		inline UInt_t GetIndexBit() const { return(kMrbSevtBit%%SEVT_NAME_UC%%); };	// subevent index bit

	protected:
		inline void SetTimeStamp(Int_t TimeStamp) { SetUniqueID(TimeStamp); };

	protected:
		TString fSevtName;						//! subevent name
		TObject * fMyAddr;						//! ptr to subevent to be used in TTree::Branch() (online)
		TBranch * fBranch;						//! branch address (replay only)

		Int_t fTimeStamp;						// time stamp, same as fUniqueID

		UInt_t * fChanDataS[kNofChannels];		// pointer to samples data
		UInt_t * fChanDataT[kNofChannels];		// pointer to trigger data
		Bool_t fChanTriggered[kNofChannels];	// kTRUE if channel triggered
		Bool_t fChanOverflow[kNofChannels]; 	// channel has overflow
		Int_t fDataSize[kNofChannels];			// size of data
		Int_t fPageSize[kNofChannels];			// max channel size

// define private data members here
%%BeginOfCode%%	
%C% 	UInt_t $paramNameLC$type[$pageSize];			// $sevtNameLC.$paramNameLC $xtype
%%EndOfCode%%
%%SEVT_PRIVATE_DATA%%

//%%SEVT_USER_DATA%%			user-specific data members may be included here
		
	ClassDef(TUsrSevt%%SEVT_NAME_UC%%, 1)			// [Analyze] Store SIS data in hit buffer
};
