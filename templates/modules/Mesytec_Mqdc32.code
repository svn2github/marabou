/*_________________________________________________________________[CODE FILE]
//////////////////////////////////////////////////////////////////////////////
// Name:           Mesytec_Mqdc32.code
// Purpose:        Code for Mesytec adc type MQDC-32
// Description:    Contains template code to operate a MQDC-32 module
// Author:         R. Lutter
// Revision:
// Date:
// Keywords:
////////////////////////////////////////////////////////////////////////////*/

%%BeginOfCode%%
#include "mqdc32.h"
#include "mqdc32_protos.h"
%%EndOfCode%%
%%MODULE_DEFS%%

%%BeginOfCode%%

%%EndOfCode%%
%%INIT_COMMON_CODE%%

%%BeginOfCode%%

									/* init module $moduleNameLC at addr $baseAddr */
					f_ut_send_msg("m_read_meb", "Initializing module $moduleNameLC in $modulePosition: $moduleTitle\n", ERR__MSG_INFO, MASK__PRTT);
					s_$moduleNameLC = mqdc32_alloc("$moduleNameLC", md_$moduleNameLC, $moduleSerial); /* allocate data struct */
 					moduleTable[kMrbModule$moduleNameUC - 1].devStruct = (void *) s_$moduleNameLC;
					mqdc32_moduleInfo(s_$moduleNameLC);						/* read module info */
					mqdc32_soft_reset(s_$moduleNameLC);	 						/* reset module */
					mqdc32_fillStruct(s_$moduleNameLC, "$settingsFile");		/* fill database from environment data */
					mqdc32_loadFromDb(s_$moduleNameLC, $chnPattern); 			/* load module regs from database */
					if (mqdc32_mcstIsEnabled(s_$moduleNameLC)) {
						mesytec_use_mcst = TRUE;
						if (mqdc32_isFirstInChain(s_$moduleNameLC)) mesytec_firstModuleInChain = (void *) s_$moduleNameLC;
					}
					if (mqdc32_useBLT(s_$moduleNameLC)) use_block_xfer = TRUE;	/* check if block xfer should be enabled */
					mqdc32_setModuleId(s_$moduleNameLC, $serial); 				/* update module id */
					mqdc32_dumpRegisters(s_$moduleNameLC, "$dumpFile"); 		/* dump registers to file */
					mqdc32_initialize(s_$moduleNameLC);		 					/* initialize module */
%%EndOfCode%%
%%INIT_MODULE%%

%%BeginOfCode%%
						if (mqdc32_useBLT(s_$moduleName)) {
							mapBLT(md_$moduleName, $baseAddr, $size, $addrMod);
							setBLTMode(md_$moduleName, BMA_M_Vsz32, BMA_M_WzD32, $fifoMode);
						}
%%EndOfCode%%
%%INIT_BLOCK_XFER%%

%%BeginOfCode%%

%%EndOfCode%%
%%INIT_CHANNEL%%

%%BeginOfCode%%

%%EndOfCode%%
%%READ_CHANNEL%%

%%BeginOfCode%%
					evt.out32 += mqdc32_readout(s_$moduleName, (uint32_t *) evt.out32);	/* read data */
%%EndOfCode%%
%%READ_MODULE%%

%%BeginOfCode%%

%%EndOfCode%%
%%INCREMENT_CHANNEL%%

%%BeginOfCode%%

%%EndOfCode%%
%%SKIP_CHANNELS%%

%%BeginOfCode%%

%%EndOfCode%%
%%WRITE_SUBADDR%%

%%BeginOfCode%%

%%EndOfCode%%
%%STORE_DATA%%

%%BeginOfCode%%

%%EndOfCode%%
%%CLEAR_MODULE%%

%%BeginOfCode%%

%%EndOfCode%%
%%SETUP_READOUT%%

%%BeginOfCode%%

%%EndOfCode%%
%%FINISH_READOUT%%

%%BeginOfCode%%
%M%							if (mesytec_use_mcst && (mesytec_firstModuleInChain == (void *) s_$moduleName)) { 	/* start modules in multicast mode */
%M%								sprintf(msg, "[Starting Mesytec modules via MCST - first module in chain is %s]\n", s_$moduleName->moduleName);
%M% 								f_ut_send_msg("m_read_meb", msg, ERR__MSG_ERROR, MASK__PRTT);
%M%								mqdc32_stopAcq_mcst(s_$moduleName);
%M%								mqdc32_startAcq_mcst(s_$moduleName);
%M%							}
%M%							if (!mesytec_use_mcst) {
%M%								mqdc32_stopAcq(s_$moduleName);	/* start module $moduleName */
%M%								mqdc32_startAcq(s_$moduleName);
%M%							}
%N%							if (!mesytec_use_mcst) {
%N%								mqdc32_stopAcq(s_$moduleName);	/* start module $moduleName */
%N%								mqdc32_startAcq(s_$moduleName);
%N%							}
%%EndOfCode%%
%%START_ACQUISITION%%

%%BeginOfCode%%

%%EndOfCode%%
%%START_ACQUISITION_GROUP%%

%%BeginOfCode%%
%M%							if (mesytec_use_mcst && (mesytec_firstModuleInChain == (void *) s_$moduleName)) { 	/* stop modules in multicast mode */
%M%								sprintf(msg, "[Stopping Mesytec modules via MCST - first module in chain is %s]\n", s_$moduleName->moduleName);
%M% 								f_ut_send_msg("m_read_meb", msg, ERR__MSG_ERROR, MASK__PRTT);
%M%									mqdc32_stopAcq_mcst(s_$moduleName);
%M%							}
%M%							if (!mesytec_use_mcst) {
%M%								mqdc32_stopAcq(s_$moduleName);	/* stop module $moduleName */
%M%							}
%N%							if (!mesytec_use_mcst) {
%N%								mqdc32_stopAcq(s_$moduleName);	/* stop module $moduleName */
%N%							}
%%EndOfCode%%
%%STOP_ACQUISITION%%

%%BeginOfCode%%

%%EndOfCode%%
%%STOP_ACQUISITION_GROUP%%

%%BeginOfCode%%

%%EndOfCode%%
%%UTILITIES%%

%%BeginOfCode%%

%%EndOfCode%%
%%DEFINE_PROTOTYPES%%

%%BeginOfCode%%
static struct s_mqdc32 * s_$moduleName;
%%EndOfCode%%
%%DEFINE_GLOBALS%%

%%BeginOfCode%%
static bool_t mesytec_use_mcst;
static void * mesytec_firstModuleInChain;
%%EndOfCode%%
%%DEFINE_GLOBALS_ONCE_ONLY%%

%%BeginOfCode%%

%%EndOfCode%%
%%DEFINE_LOCAL_VARS_INIT%%

%%BeginOfCode%%

%%EndOfCode%%
%%DEFINE_LOCAL_VARS_READOUT%%

%%BeginOfCode%%
	-I@{.PPCIncludePath:/nfs/marabou/include}
%%EndOfCode%%
%%DEFINE_INCLUDE_PATHS%%

%%BeginOfCode%%
	-L$ppcLibraryPath -lMqdc32
%%EndOfCode%%
%%DEFINE_LIBRARIES%%

