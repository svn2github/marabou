static const char rcsId[] = "$Header: /u/hadaq/CVS/allParam/ora/oraParam.pc,v 1.28 2003/01/31 16:40:18 hadaq Exp $";
#define _POSIX_C_SOURCE 199509L

#if HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/utsname.h>

#include <oraca.h>
#include <sqlca.h>

#include "../include/allParam.h"

static void Param_rollback();

static void Param_strerror(const Param *, const char *);

typedef struct OraParamS {
	const char *user;
	const char *passwd;
} OraParam;

int conSetupParam(Param *my, const char *setup)
{
	int row = 0;
	struct utsname bufferS, *buffer = &bufferS;
	EXEC SQL BEGIN DECLARE SECTION;
	const char* un;
	const char* pw;
	EXEC SQL END DECLARE SECTION;

	my->strerror = NULL;
	if(setup != NULL) {
		my->setup = malloc(strlen(setup) + 1);
		strcpy(my->setup, setup);
	} else {
		my->setup = NULL;
	}
	my->specParam = malloc(sizeof(OraParam));
	((OraParam *) (my->specParam))->user = "daq_oper@db-hades.gsi.de";
	((OraParam *) (my->specParam))->passwd = "daqall";

	un = ((OraParam *) (my->specParam))->user;
	pw = ((OraParam *) (my->specParam))->passwd;

	EXEC SQL CONNECT :un IDENTIFIED BY :pw;

	my->basedir = malloc(PARAM_MAX_VALUE_LEN);
	uname(buffer);
	if(Param_getString(my, buffer->nodename, "basedir", &row, my->basedir) || (row != 1)) {
		strcpy(my->basedir, "");
	} else if (strlen(my->basedir)) {
		strcat(my->basedir, "/");
	}

	return 0;
}

int conParam(Param *my)
{
	return conSetupParam(my, NULL);
}

void desParam(Param *my)
{
	EXEC SQL COMMIT RELEASE;

	free(my->specParam);
	free(my->basedir);
	if(my->setup != NULL) {
		free(my->setup);
	}
}

int Param_getInt(const Param *my, const char *name, const char *idx, int *row, unsigned long int *val)
{
	return Param_getIntArray(my, name, idx, 1, row, val);
}

int Param_getString(const Param *my, const char *name, const char *idx, int *row, char *val)
{
	return Param_getStringArray(my, name, idx, 1, row, &val);
}

int Param_getFilename(const Param *my, const char *name, const char *idx, int *row, char *val)
{
	return Param_getFilenameArray(my, name, idx, 1, row, &val);
}

int Param_getIntArray(const Param *my, const char *name, const char *idx, int maxrows, int *rows, unsigned long int *val)
{
	int retVal = 0;
	int i;

	EXEC SQL WHENEVER SQLERROR DO Param_strerror(my, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR DO Param_rollback();

	EXEC SQL BEGIN DECLARE SECTION;
	int l_valid;
	int l_locked;
	char sqlsetup[PARAM_MAX_NAME_LEN];
	char sqlname[PARAM_MAX_NAME_LEN];
	char sqlidx[PARAM_MAX_NAME_LEN];
	unsigned long int value[PARAM_MAX_ARRAY_LEN];
	EXEC SQL END DECLARE SECTION;

	if (my->setup != NULL) {
		for(i = 0 ; i <= strlen(my->setup) ; i++) {
			sqlsetup[i] = tolower((my->setup)[i]);
		}
	} else {
		strcpy(sqlsetup, "");
	}
	for(i = 0 ; i <= strlen(name) ; i++) {
		sqlname[i] = tolower(name[i]);
	}
	for(i = 0 ; i <= strlen(idx) ; i++) {
		sqlidx[i] = tolower(idx[i]);
	}

	if (my->setup != NULL) {
		EXEC SQL EXECUTE
			BEGIN
			SELECT
					valid, locked
				INTO
					:l_valid, :l_locked
				FROM
					daq.cache_table_valid
				WHERE
					cache_table = 'param_int_cache';
			IF
				:l_valid = 0 AND :l_locked = 0
			THEN
				daq.daq_oper_interface.validate_cache_table ( 'param_int_cache' );
			END IF;
			END;
		END-EXEC;
			EXEC SQL SELECT
					value
				INTO
					:value
				FROM
					daq.param_int_cache
				WHERE
						setup = :sqlsetup
					AND
						name = :sqlname
					AND
						idx = :sqlidx
				ORDER BY
					seq_num;
	} else {
		EXEC SQL EXECUTE
			BEGIN
			SELECT
					valid, locked
				INTO
					:l_valid, :l_locked
				FROM
					daq.cache_table_valid
				WHERE
					cache_table = 'param_int_cache';
			IF
				:l_valid = 0 AND :l_locked = 0
			THEN
				daq.daq_oper_interface.validate_cache_table ( 'param_int_cache' );
			END IF;
			END;
		END-EXEC;
			EXEC SQL SELECT
					value
				INTO
					:value
				FROM
					daq.param_int_cache
				WHERE
						setup IS NULL
					AND
						name = :sqlname
					AND
						idx = :sqlidx
				ORDER BY
					seq_num;
	}

	*rows = sqlca.sqlerrd[2];

	if (*rows > maxrows) {
		*rows = maxrows;
	}
	for (i = 0 ; i < *rows ; i++) {
		val[i] = value[i];
	}

	EXEC SQL COMMIT;
	return retVal;
}

int Param_getStringArray(const Param *my, const char *name, const char *idx, int maxrows, int *rows, char **val)
{
	int retVal = 0;
	int i;

	EXEC SQL WHENEVER SQLERROR DO Param_strerror(my, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR DO Param_rollback();

	EXEC SQL BEGIN DECLARE SECTION;
	int l_valid;
	int l_locked;
	char sqlsetup[PARAM_MAX_NAME_LEN];
	char sqlname[PARAM_MAX_NAME_LEN];
	char sqlidx[PARAM_MAX_NAME_LEN];
	char value[PARAM_MAX_ARRAY_LEN][PARAM_MAX_VALUE_LEN];
	EXEC SQL END DECLARE SECTION;

	if (my->setup != NULL) {
		for(i = 0 ; i <= strlen(my->setup) ; i++) {
			sqlsetup[i] = tolower((my->setup)[i]);
		}
	} else {
		strcpy(sqlsetup, "");
	}
	for(i = 0 ; i <= strlen(name) ; i++) {
		sqlname[i] = tolower(name[i]);
	}
	for(i = 0 ; i <= strlen(idx) ; i++) {
		sqlidx[i] = tolower(idx[i]);
	}

	if (my->setup != NULL) {
		EXEC SQL EXECUTE
			BEGIN
			SELECT
					valid, locked
				INTO
					:l_valid, :l_locked
				FROM
					daq.cache_table_valid
				WHERE
					cache_table = 'param_string_cache';
			IF
				:l_valid = 0 AND :l_locked = 0
			THEN
				daq.daq_oper_interface.validate_cache_table ( 'param_string_cache' );
			END IF;
			END;
		END-EXEC;
			EXEC SQL SELECT
					value
				INTO
					:value
				FROM
					daq.param_string_cache
				WHERE
						setup = :sqlsetup
					AND
						name = :sqlname
					AND
						idx = :sqlidx
				ORDER BY
					seq_num;
	} else {
		EXEC SQL EXECUTE
			BEGIN
			SELECT
					valid, locked
				INTO
					:l_valid, :l_locked
				FROM
					daq.cache_table_valid
				WHERE
					cache_table = 'param_string_cache';
			IF
				:l_valid = 0 AND :l_locked = 0
			THEN
				daq.daq_oper_interface.validate_cache_table ( 'param_string_cache' );
			END IF;
			END;
		END-EXEC;
			EXEC SQL SELECT
					value
				INTO
					:value
				FROM
					daq.param_string_cache
				WHERE
						setup IS NULL
					AND
						name = :sqlname
					AND
						idx = :sqlidx
				ORDER BY
					seq_num;
	}

	*rows = sqlca.sqlerrd[2];

	if (*rows == 0) {
		EXEC SQL BEGIN DECLARE SECTION;
		unsigned long int intvalue[PARAM_MAX_ARRAY_LEN];
		EXEC SQL END DECLARE SECTION;

		if (my->setup != NULL) {
		EXEC SQL EXECUTE
			BEGIN
			SELECT
					valid, locked
				INTO
					:l_valid, :l_locked
				FROM
					daq.cache_table_valid
				WHERE
					cache_table = 'param_int_cache';
			IF
				:l_valid = 0 AND :l_locked = 0
			THEN
				daq.daq_oper_interface.validate_cache_table ( 'param_int_cache' );
			END IF;
			END;
		END-EXEC;
			EXEC SQL SELECT
					value
				INTO
					:intvalue
				FROM
					daq.param_int_cache
				WHERE
						setup = :sqlsetup
					AND
						name = :sqlname
					AND
						idx = :sqlidx
				ORDER BY
					seq_num;
		} else {
		EXEC SQL EXECUTE
			BEGIN
			SELECT
					valid, locked
				INTO
					:l_valid, :l_locked
				FROM
					daq.cache_table_valid
				WHERE
					cache_table = 'param_int_cache';
			IF
				:l_valid = 0 AND :l_locked = 0
			THEN
				daq.daq_oper_interface.validate_cache_table ( 'param_int_cache' );
			END IF;
			END;
		END-EXEC;
			EXEC SQL SELECT
					value
				INTO
					:intvalue
				FROM
					daq.param_int_cache
				WHERE
						setup IS NULL
					AND
						name = :sqlname
					AND
						idx = :sqlidx
				ORDER BY
					seq_num;
		}

		*rows = sqlca.sqlerrd[2];

		if (*rows > maxrows) {
			*rows = maxrows;
		}
		for (i = 0 ; i < *rows ; i++) {
			sprintf(val[i], "%ld", intvalue[i]);
		}
	} else {
		if (*rows > maxrows) {
			*rows = maxrows;
		}
		for (i = 0 ; i < *rows ; i++) {
			int j = PARAM_MAX_VALUE_LEN - 1;
			while(value[i][--j] == ' ');
			value[i][j + 1] = '\0';
			strcpy(val[i], value[i]);
		}
	}

	EXEC SQL COMMIT;
	return retVal;
}

int Param_getFilenameArray(const Param *my, const char *name, const char *idx, int maxrows, int *rows, char **val)
{
	int retVal = 0;
	int i;
	char *value[PARAM_MAX_ARRAY_LEN];

	for (i = 0 ; i < maxrows ; i++) {
		value[i] = malloc(PARAM_MAX_VALUE_LEN);
	}

	if (((retVal = Param_getStringArray(my, name, idx, maxrows, rows, value)) == 0) && (*rows > 0)) {
		for (i = 0 ; i < *rows ; i++) {
			if (value[i][0] != '/') {
				strcpy(val[i], my->basedir);
			} else {
				strcpy(val[i], "");
			}
			strcat(val[i], value[i]);
		}
	} else {
		*rows = 0;
	}

	for (i = 0 ; i < maxrows ; i++) {
		free(value[i]);
	}

	return retVal;
}

int Param_getBlob(const Param *my, const char *name, const char *idx, size_t *size, FILE **val)
{
	int retVal = 0;
	char filename[PARAM_MAX_VALUE_LEN];
	int rows;
	FILE *stream;

	retVal = Param_getFilename(my, name, idx, &rows, filename);
	if ((rows == 0) || (stream = fopen(filename, "r")) == NULL) {
		Param_strerror((Param *) my, strerror(errno));
		*size = 0;
		retVal = -1;
	} else {
		struct stat fileS, *file = &fileS;
		stat(filename, file);
		*size = (size_t) file->st_size;
		*val = stream;
	}
	return retVal;
}

int Param_storeInt(const Param *my, const char *name, const char *idx, unsigned long int val)
{
	int i;

	EXEC SQL WHENEVER SQLERROR DO Param_strerror(my, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR DO Param_rollback();

	EXEC SQL BEGIN DECLARE SECTION;
	char sqlsetup[PARAM_MAX_NAME_LEN];
	char sqlname[PARAM_MAX_NAME_LEN];
	char sqlidx[PARAM_MAX_NAME_LEN];
	unsigned long int value;
	EXEC SQL END DECLARE SECTION;

	if (my->setup != NULL) {
		for(i = 0 ; i <= strlen(my->setup) ; i++) {
			sqlsetup[i] = tolower((my->setup)[i]);
		}
	} else {
		strcpy(sqlsetup, "");
	}
	for(i = 0 ; i <= strlen(name) ; i++) {
		sqlname[i] = tolower(name[i]);
	}
	for(i = 0 ; i <= strlen(idx) ; i++) {
		sqlidx[i] = tolower(idx[i]);
	}
	value = val;


	EXEC SQL EXECUTE
		BEGIN
			daq.daq_oper_interface.store_param_int ( :sqlsetup, :sqlname, :sqlidx, :value );
		END;
	END-EXEC;

	EXEC SQL COMMIT;
	return 0;
}

int Param_storeString(const Param *my, const char *name, const char *idx, const char *val)
{
	int i;

	EXEC SQL WHENEVER SQLERROR DO Param_strerror(my, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR DO Param_rollback();

	EXEC SQL BEGIN DECLARE SECTION;
	char sqlsetup[PARAM_MAX_NAME_LEN];
	char sqlname[PARAM_MAX_NAME_LEN];
	char sqlidx[PARAM_MAX_NAME_LEN];
	const char *value;
	EXEC SQL END DECLARE SECTION;

	if (my->setup != NULL) {
		for(i = 0 ; i <= strlen(my->setup) ; i++) {
			sqlsetup[i] = tolower((my->setup)[i]);
		}
	} else {
		strcpy(sqlsetup, "");
	}
	for(i = 0 ; i <= strlen(name) ; i++) {
		sqlname[i] = tolower(name[i]);
	}
	for(i = 0 ; i <= strlen(idx) ; i++) {
		sqlidx[i] = tolower(idx[i]);
	}
	value = val;


	EXEC SQL EXECUTE
		BEGIN
			daq.daq_oper_interface.store_param_string ( :sqlsetup, :sqlname, :sqlidx, :value );
		END;
	END-EXEC;

	EXEC SQL COMMIT;
	return 0;
}

void Param_clearCache(const Param *my)
{
}

const char *Param_getErrStr(const Param *my)
{
	return my->strerror;
}

static void Param_strerror(const Param *my, const char *strerror)
{
	((Param *) my)->strerror = realloc(my->strerror, strlen(strerror) + 1);
	if(((Param *) my)->strerror != NULL) {
		strcpy(((Param *) my)->strerror, strerror);
	}
}

static void Param_rollback()
{
	EXEC SQL ROLLBACK;
}

